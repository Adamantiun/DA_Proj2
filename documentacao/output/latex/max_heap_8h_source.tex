\hypertarget{max_heap_8h_source}{}\doxysection{max\+Heap.\+h}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 }
\DoxyCodeLine{2 \textcolor{preprocessor}{\#ifndef UNTITLED\_MAXHEAP\_H}}
\DoxyCodeLine{3 \textcolor{preprocessor}{\#define UNTITLED\_MAXHEAP\_H}}
\DoxyCodeLine{4 }
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <unordered\_map>}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{9 \textcolor{keyword}{using namespace }std;}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{comment}{// Data structure to store a max-\/heap node}}
\DoxyCodeLine{12 \textcolor{keyword}{class }\mbox{\hyperlink{class_priority_queue}{PriorityQueue}}}
\DoxyCodeLine{13 \{}
\DoxyCodeLine{14     \textcolor{keyword}{struct }Node \{ \textcolor{comment}{// An element of the heap: a pair (key, value)}}
\DoxyCodeLine{15         \textcolor{keywordtype}{int} key;}
\DoxyCodeLine{16         \textcolor{keywordtype}{int} value;}
\DoxyCodeLine{17     \};}
\DoxyCodeLine{18 \textcolor{keyword}{private}:}
\DoxyCodeLine{19     \textcolor{comment}{// vector to store heap elements}}
\DoxyCodeLine{20     vector<Node> A;}
\DoxyCodeLine{21     unordered\_map<int, int> pos; \textcolor{comment}{// maps a key into its position on the array a}}
\DoxyCodeLine{22     \textcolor{keywordtype}{int} s;}
\DoxyCodeLine{23 }
\DoxyCodeLine{24     \textcolor{comment}{// return parent of `A[i]`}}
\DoxyCodeLine{25     \textcolor{comment}{// don't call this function if `i` is already a root node}}
\DoxyCodeLine{26     \textcolor{keywordtype}{int} PARENT(\textcolor{keywordtype}{int} i) \{}
\DoxyCodeLine{27         \textcolor{keywordflow}{return} (i -\/ 1) / 2;}
\DoxyCodeLine{28     \}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30     \textcolor{comment}{// return left child of `A[i]`}}
\DoxyCodeLine{31     \textcolor{keywordtype}{int} LEFT(\textcolor{keywordtype}{int} i) \{}
\DoxyCodeLine{32         \textcolor{keywordflow}{return} (2*i + 1);}
\DoxyCodeLine{33     \}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35     \textcolor{comment}{// return right child of `A[i]`}}
\DoxyCodeLine{36     \textcolor{keywordtype}{int} RIGHT(\textcolor{keywordtype}{int} i) \{}
\DoxyCodeLine{37         \textcolor{keywordflow}{return} (2*i + 2);}
\DoxyCodeLine{38     \}}
\DoxyCodeLine{39 }
\DoxyCodeLine{40     \textcolor{comment}{// Recursive heapify-\/down algorithm.}}
\DoxyCodeLine{41     \textcolor{comment}{// The node at index `i` and its two direct children}}
\DoxyCodeLine{42     \textcolor{comment}{// violates the heap property}}
\DoxyCodeLine{43     \textcolor{keywordtype}{void} heapify\_down(\textcolor{keywordtype}{int} i)}
\DoxyCodeLine{44     \{}
\DoxyCodeLine{45         \textcolor{comment}{// get left and right child of node at index `i`}}
\DoxyCodeLine{46         \textcolor{keywordtype}{int} left = LEFT(i);}
\DoxyCodeLine{47         \textcolor{keywordtype}{int} right = RIGHT(i);}
\DoxyCodeLine{48 }
\DoxyCodeLine{49         \textcolor{keywordtype}{int} largest = i;}
\DoxyCodeLine{50 }
\DoxyCodeLine{51         \textcolor{comment}{// compare `A[i]` with its left and right child}}
\DoxyCodeLine{52         \textcolor{comment}{// and find the largest value}}
\DoxyCodeLine{53         \textcolor{keywordflow}{if} (left < size() \&\& A[left].value > A[i].value) \{}
\DoxyCodeLine{54             largest = left;}
\DoxyCodeLine{55         \}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57         \textcolor{keywordflow}{if} (right < size() \&\& A[right].value > A[largest].value) \{}
\DoxyCodeLine{58             largest = right;}
\DoxyCodeLine{59         \}}
\DoxyCodeLine{60 }
\DoxyCodeLine{61         \textcolor{comment}{// swap with a child having greater value and}}
\DoxyCodeLine{62         \textcolor{comment}{// call heapify-\/down on the child}}
\DoxyCodeLine{63         \textcolor{keywordflow}{if} (largest != i)}
\DoxyCodeLine{64         \{}
\DoxyCodeLine{65             swap(A[i], A[largest]);}
\DoxyCodeLine{66             heapify\_down(largest);}
\DoxyCodeLine{67         \}}
\DoxyCodeLine{68     \}}
\DoxyCodeLine{69 }
\DoxyCodeLine{70     \textcolor{comment}{// Recursive heapify-\/up algorithm}}
\DoxyCodeLine{71     \textcolor{keywordtype}{void} heapify\_up(\textcolor{keywordtype}{int} i)}
\DoxyCodeLine{72     \{}
\DoxyCodeLine{73         \textcolor{comment}{// check if the node at index `i` and its parent violate the heap property}}
\DoxyCodeLine{74         \textcolor{keywordflow}{if} (i \&\& A[PARENT(i)].value < A[i].value)}
\DoxyCodeLine{75         \{}
\DoxyCodeLine{76             \textcolor{comment}{// swap the two if heap property is violated}}
\DoxyCodeLine{77             swap(A[i], A[PARENT(i)]);}
\DoxyCodeLine{78 }
\DoxyCodeLine{79             \textcolor{comment}{// call heapify-\/up on the parent}}
\DoxyCodeLine{80             heapify\_up(PARENT(i));}
\DoxyCodeLine{81         \}}
\DoxyCodeLine{82     \}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{keyword}{public}:}
\DoxyCodeLine{85     \mbox{\hyperlink{class_priority_queue}{PriorityQueue}}()\{}
\DoxyCodeLine{86         this-\/>s=0;}
\DoxyCodeLine{87     \}}
\DoxyCodeLine{88     \textcolor{keywordtype}{void} clean()\{}
\DoxyCodeLine{89         A.clear();}
\DoxyCodeLine{90         s=0;}
\DoxyCodeLine{91     \}}
\DoxyCodeLine{92 }
\DoxyCodeLine{93     \textcolor{keywordtype}{bool} hasKey(\textcolor{keyword}{const} \textcolor{keywordtype}{int} key) \{}
\DoxyCodeLine{94         \textcolor{keywordflow}{return} pos.find(key) != pos.end();}
\DoxyCodeLine{95     \}}
\DoxyCodeLine{96 }
\DoxyCodeLine{97     \textcolor{comment}{// return size of the heap}}
\DoxyCodeLine{98     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} size() \{}
\DoxyCodeLine{99         \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{100     \}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102     \textcolor{comment}{// Function to check if the heap is empty or not}}
\DoxyCodeLine{103     \textcolor{keywordtype}{bool} empty() \{}
\DoxyCodeLine{104         \textcolor{keywordflow}{return} size() == 0;}
\DoxyCodeLine{105     \}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107     \textcolor{comment}{// insert key into the heap}}
\DoxyCodeLine{108     \textcolor{keywordtype}{void} push(\textcolor{keywordtype}{int} key, \textcolor{keywordtype}{int} value)}
\DoxyCodeLine{109     \{}
\DoxyCodeLine{110         s++;}
\DoxyCodeLine{111         Node n;}
\DoxyCodeLine{112         pos[key] = s-\/1;}
\DoxyCodeLine{113         n.value=value;}
\DoxyCodeLine{114         n.key=key;}
\DoxyCodeLine{115         \textcolor{comment}{// insert a new element at the end of the vector}}
\DoxyCodeLine{116         A.push\_back(n);}
\DoxyCodeLine{117 }
\DoxyCodeLine{118         \textcolor{comment}{// get element index and call heapify-\/up procedure}}
\DoxyCodeLine{119         \textcolor{keywordtype}{int} index = size() -\/ 1;}
\DoxyCodeLine{120         heapify\_up(index);}
\DoxyCodeLine{121     \}}
\DoxyCodeLine{122 }
\DoxyCodeLine{123     \textcolor{comment}{// Function to remove an element with the highest priority (present at the root)}}
\DoxyCodeLine{124     \textcolor{keywordtype}{void} pop()}
\DoxyCodeLine{125     \{}
\DoxyCodeLine{126             \textcolor{comment}{// if the heap has no elements, throw an exception}}
\DoxyCodeLine{127             \textcolor{keywordflow}{if} (size() == 0)}
\DoxyCodeLine{128             \{}
\DoxyCodeLine{129                 \textcolor{keywordflow}{throw} out\_of\_range(\textcolor{stringliteral}{"{}Vector<X>::at() : "{}}}
\DoxyCodeLine{130                                    \textcolor{stringliteral}{"{}index is out of range(Heap underflow)"{}});}
\DoxyCodeLine{131             \}}
\DoxyCodeLine{132 }
\DoxyCodeLine{133             \textcolor{comment}{// replace the root of the heap with the last element}}
\DoxyCodeLine{134             \textcolor{comment}{// of the vector}}
\DoxyCodeLine{135             A[0] = A.back();}
\DoxyCodeLine{136             pos.erase(A.back().key);}
\DoxyCodeLine{137             A.pop\_back();}
\DoxyCodeLine{138             s-\/-\/;}
\DoxyCodeLine{139             \textcolor{comment}{// call heapify-\/down on the root node}}
\DoxyCodeLine{140             heapify\_down(0);}
\DoxyCodeLine{141 }
\DoxyCodeLine{142     \}}
\DoxyCodeLine{143     \textcolor{keywordtype}{void} increaseKey(\textcolor{keyword}{const} \textcolor{keywordtype}{int} key, \textcolor{keyword}{const} \textcolor{keywordtype}{int} value) \{}
\DoxyCodeLine{144         \textcolor{keywordflow}{if} (!hasKey(key)) \textcolor{keywordflow}{return}; \textcolor{comment}{// key does not exist, do nothing}}
\DoxyCodeLine{145         \textcolor{keywordtype}{int} i = pos[key];}
\DoxyCodeLine{146         \textcolor{keywordflow}{if} (value < A[i].value) \textcolor{keywordflow}{return}; \textcolor{comment}{// value would increase, do nothing}}
\DoxyCodeLine{147         A[i].value = value;}
\DoxyCodeLine{148         heapify\_down(i);}
\DoxyCodeLine{149     \}}
\DoxyCodeLine{150 }
\DoxyCodeLine{151 }
\DoxyCodeLine{152     \textcolor{comment}{// Function to return an element with the highest priority (present at the root)}}
\DoxyCodeLine{153     \textcolor{keywordtype}{int} top()}
\DoxyCodeLine{154     \{}
\DoxyCodeLine{155             \textcolor{comment}{// if the heap has no elements, throw an exception}}
\DoxyCodeLine{156             \textcolor{keywordflow}{if} (size() == 0)}
\DoxyCodeLine{157             \{}
\DoxyCodeLine{158                 \textcolor{keywordflow}{throw} out\_of\_range(\textcolor{stringliteral}{"{}Vector<X>::at() : "{}}}
\DoxyCodeLine{159                                    \textcolor{stringliteral}{"{}index is out of range(Heap underflow)"{}});}
\DoxyCodeLine{160             \}}
\DoxyCodeLine{161 }
\DoxyCodeLine{162             \textcolor{comment}{// otherwise, return the top (first) element}}
\DoxyCodeLine{163             \textcolor{keywordflow}{return} A.at(0).key;        \textcolor{comment}{// or return A[0];}}
\DoxyCodeLine{164     \}}
\DoxyCodeLine{165 \};}
\DoxyCodeLine{166 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//DA\_PROJ2\_MAXHEAP\_H}}

\end{DoxyCode}
